title: Server Side Dynamic Elements
date: 2010/10/06
author: Andrew

I am a big fan of Ruby and most of the things that come with it. The exception to this is 
the overhead generated by dynamic websites built upon it. Server side dynamic content generation is 
a big issue that I have run up against many, many times. In light of these issues, I had originally 
planned to do client side parsing of the Twitter, Flickr, and Delicious streams that I integrate 
into [amdavidson.com](http://amdavidson.com). 

This worked fine until I left the country on a business trip to China and realized that the Great 
Firewall of China would not block the client side scripts from getting at Twitter, but just let 
them time out. This led to awful page loading times.

I have been looking to switch amdavidson.com back to Ruby for some time as I don't much like working 
with PHP. This gave me a good opportunity for a rewrite and here's some server side parsing that I 
worked out. 

For Twitter I wanted to pull the <code>JSON</code> data stream and do some basic formatting and 
linkify the usernames and URLs in any of the tweets. I came up with the following code:
	<% 	if twitter_enabled == true then
			require 'open-uri'
			require 'json/ext'
			
			twitter_url = "https://api.twitter.com/1/statuses/user_timeline.json?screen_name=amdavidson"
			response = open(twitter_url, 'User-agent' => 'amdavidson.com').read
			tweets = JSON.parse(response)
			
			def linkify(text)
				text = text.gsub(/(?i)\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?«»“”‘’]))/, '<a href="\\1">\\1</a>')
				text = text.gsub(/@([A-Za-z0-9]*)/, '<a href="http://twitter.com/\\1">@\\1</a>');
				text
			end
			
			
			for t in tweets[0...5] do
		%>
		
				<div class="tweet tweet-<%= t["id"] %>">
					<a href="http://twitter.com/<%= t["user"]["screen_name"] %>"><img width="48" height="48" src="<%= t["user"]["profile_image_url"]%>" rel="<%= t["user"]["profile_image_url"] %>" /></a>
					<p class="text">
						<span class="username"><a href="http://twitter.com/<%= t["user"]["screen_name"] %>"><%= t["user"]["screen_name"] %></a>:</span>
						<%= linkify(t["text"]) %>
						<% if t["in_reply_to_screen_name"] then %>
							<span class="time"><%= DateTime.parse(t["created_at"]).strftime("%B %e at %l:%m") %> in reply to 
							<a href="http://twitter.com/<%= t["in_reply_to_screen_name"] %>/status/<%= t["in_reply_to_status_id"]%>"><%= t["in_reply_to_screen_name"] %></a></span>
						<% else %>
							<span class="time"><%= DateTime.parse(t["created_at"]).strftime("%B %e at %l:%m") %></span>							
						<% end %>
					</p>
				</div>
	
	<%		end
		end %>
		
Breaking that down a little, I pulled the stream using <code>open-uri</code>, then parsed it using 
<code>JSON.parse</code>, then linkified it using John Gruber's excellent (and extremely long) 
[url matching regex](http://daringfireball.net/2010/07/improved_regex_for_matching_urls) and a regex 
of my own design for linkifying the twitter usernames that are mentioned in a tweet. The rest of the 
code is just formatting. 

Here's a bit simpler code for my 12 most recent Flickr images:
		<%	if flickr_enabled == true then
		
			require 'open-uri'
			require 'json/ext'
			
			flickr_url = "http://api.flickr.com/services/rest/?&method=flickr.people.getPublicPhotos&format=json&nojsoncallback=1&api_key=#{ENV['flickr_key']}&user_id=#{ENV['flickr_id']}&per_page=12"
			response = open(flickr_url, 'User-agent' => 'amdavidson.com').read
			photos = JSON.parse(response)["photos"]["photo"]
			
			for p in photos[0...12] do
				square = "http://farm#{p["farm"]}.static.flickr.com/#{p["server"]}/#{p["id"]}_#{p["secret"]}_t.jpg"
				medium = "http://farm#{p["farm"]}.static.flickr.com/#{p["server"]}/#{p["id"]}_#{p["secret"]}.jpg"
				url = "http://flickr.com/photos/#{p["owner"]}/#{p["id"]}"
		%>
			
		<a class="preview" href="<%= url %>" rel="<%= medium %>">
			<img class="flickr-img" src="<%= square %>" alt="" />
		</a>

		<% 	end
		end %>
		
And my code for Delicious: 

			<%
			
			if delicious_enabled == true then
			
				require 'open-uri'
				require 'json/ext'
				
				url = "http://feeds.delicious.com/v2/json/#{ENV["delicious_name"]}"
				response = open(url, 'User-agent' => 'amdavidson.com').read
				links = JSON.parse(response)

				for l in links[0...5] do 		
			
			%>		
					<li>
						<h2><a href="<%= l["u"] %>" title="<%= l["d"]%>" target="_blank"><%= l["d"]%></a></h2>
						<p><%= l["n"] %></p>
					</li>
		    
		    
		    <%	end 
		    end %>
		    
		    
None of this code is very light on the server, if you have lighter methods. Please let me know. I 
would love to lighten the loads, but in the mean time I plan to try to mitigate the load with the 
Varnish <code>HTTP caching</code> that is built into Heroku.



